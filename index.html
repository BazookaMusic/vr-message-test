<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WebXR Message Placer</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/webxr/ARButton.js"></script>
</head>
<body>
    <button id="ar-button" style="position: absolute; top: 10px; left: 10px; z-index: 100;">Enter AR</button>

    <script>
        let scene, camera, renderer, controller, previewPlane;
        let planeGeometry, previewMaterial;

        // Reusable helper to get a pose from hitTest.
        function getHitTestPose(frame, inputSource) {
            const hitTestResults = frame.getHitTestResults(inputSource.targetRaySpace);
            if (hitTestResults.length > 0) {
                const hit = hitTestResults[0];
                return hit.getPose(renderer.xr.getReferenceSpace());
            }
            return null;
        }

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 20);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Create plane geometry once.
            planeGeometry = new THREE.PlaneGeometry(0.3, 0.15);

            // Materials for preview.
            previewMaterial = new THREE.MeshBasicMaterial({
                color: 0x888888,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.5,
            });

            // AR button.
            const arButton = ARButton.createButton(renderer);
            document.getElementById('ar-button').addEventListener('click', () => {
                if (!renderer.xr.isPresenting) {
                    document.body.appendChild(arButton);
                } else {
                    renderer.xr.end();
                }
            });

            // Controller.
            controller = renderer.xr.getController(0);
            controller.addEventListener('select', placeMessage);
            controller.addEventListener('squeezestart', updatePreview);
            controller.addEventListener('squeezeend', removePreview);
            scene.add(controller);

            // Start render loop.
            renderer.setAnimationLoop(() => {
                renderer.render(scene, camera);
            });
        }

        function createTextTexture(message) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            // Background
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            // Text
            ctx.fillStyle = 'black';
            ctx.font = '40px Arial';
            ctx.fillText(message, 20, 100);
            return new THREE.CanvasTexture(canvas);
        }

        function placeMessage(event) {
            const message = prompt('Enter your message:');
            if (!message) return;

            const pose = getHitTestPose(event.frame, event.inputSource);
            if (!pose) return;

            const planeMaterial = new THREE.MeshBasicMaterial({
                map: createTextTexture(message),
                side: THREE.DoubleSide,
            });
            const plane = new THREE.Mesh(planeGeometry.clone(), planeMaterial);

            plane.position.copy(pose.transform.position);
            plane.lookAt(camera.position);
            scene.add(plane);
        }

        function updatePreview(event) {
            // If not created, create one.
            if (!previewPlane) {
                previewPlane = new THREE.Mesh(planeGeometry.clone(), previewMaterial);
                scene.add(previewPlane);
            }

            const pose = getHitTestPose(event.frame, event.inputSource);
            if (pose && previewPlane) {
                previewPlane.position.copy(pose.transform.position);
                previewPlane.lookAt(camera.position);
            }
        }

        function removePreview() {
            if (previewPlane) {
                scene.remove(previewPlane);
                previewPlane = null;
            }
        }

        init();
    </script>
</body>
</html>
